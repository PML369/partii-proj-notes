Following flow of information, starting at ip_output and first working down the stack, then back up to top, then back down to ip_output:

--- IP layer entry: call to ip_output --

netinet/ip_options.c L518 : ip_insertoptions may allocate a new mbuf in order to write into the packet header
netinet/ip_output.c  L1397: ip_mloopback takes a copy of a packet mbuf so that it can send it back up the stack
netinet/ip_output.c  L1399: ip_mloopback calls m_pullup, which may allocate a new mbuf on the front of the chain, resulting in 'copym' being changed.
net/if_loop.c		 L284 : if_simloop calls m_tag_delete_nonpersistent - TODO: decide if this packet should have the same id tag or a new one
net/if_loop.c		 L288 : if_simloop calls mac_ifnet_create_mbuf - TODO: Ask Graeme to confirm (if he can) that this isn't doing anything we want to know about
net/if_loop.c  L303 & 314 : if_simloop calls bpf_mtap. ASSUMING we consider BPF (Berkley packet filter) as a different subsystem, log this
net/if_loop.c		 L321 : if_simloop calls m_adj. This may free mbufs from the chain
net/if_loop.c		 L353 : if_simloop may free mbuf chain
net/if_loop.c		 L358 : if_simloop adds mbuf to the isr queue. This represents its transition into the input system
netinet/ip_mroute.c L1298 : X_ip_mforward (alias ip_mforward) calls malloc for struct rtdetq (IP packet iformation - data, interface etc)
netinet/ip_mroute.c L1306 : X_ip_mforward (alias ip_mforward) calls m_copypacket to (deep?) clone entire packet into mb0
kern/uipc_mbuf.c	 L506 : Aside: what's with this comment? It looks like it does a deep copy to me
netinet/ip_mroute.c L1342 : X_ip_mforward (alias ip_mforward) calls malloc for struct mfc - multicast forwarding cache structure
netinet/ip_mroute.c L1347 : X_ip_mforward (alias ip_mforward) calls m_copy to copy header
netinet/ip_mroute.c L1364 : X_ip_mforward (alias ip_mforward) uses socket_send to send packet to V_ip_mrouter ("multicast routing daemon"?) [and frees an mbuf once it's done]
netinet/ip_mroute.c L1368 : X_ip_mforward (alias ip_mforward) - lots of frees in this area on error
netinet/ip_mroute.c L1402 : X_ip_mforward (alias ip_mforward) IP packet info (with mbuf pointer) submitted to queue awaiting mfc in this area
netinet/ip_mroute.c L1411 : X_ip_mforward (alias ip_mforward) - error related frees
netinet/ip_output.c  L496 : ip_output frees the packet if it is successfully forwarded to the multicast system
netinet/ip_output.c  L512 : ip_output frees the packet if it must not be sent

-<IPSec>-
netipsec/ipsec_output.c	   L470 : ipsec_encap may allocate another mbuf using m_prepend (via M_PREPEND) - may also free the mbuf if it fails
netipsec/ipsec_output.c	   L493 : ipsec_encap may allocate another mbuf using m_prepend (via M_PREPEND) - may also free the mbuf if it fails
netipsec/ipsec_output.c	   L556 : ipsec4_process_packet allows data to be accessed by the hhooks system (?) via the ctx struct
netipsec/ipsec_output.c	   L584 : ipsec4_process_packet allows data to be accessed by the hhooks system (?) via the ctx struct
netipsec/ipsec_output.c	   L614 : ipsec4_process_packet calls the crypto system's transformation output function to output the packet -- dig depper into this?
netipsec/ipsec_output.c	   L621 : ipsec4_process_packet frees packet on error
-</IPSec>-

netinet/ip_output.c		   L121 : ip_output_pfil runs PFIL hooks (they might copy things around?)
netinet/ip_output.c		   L147 : ip_output_pfil adds packet to incoming queue with netisr_queue()
netinet/ip_output.c		   L181 : ip_output_pfil adds packet to incoming queue with netisr_queue()
netinet/ip_output.c  	   L661 : ip_output hands mbuf to interface's if_output - packet leaves IP layer
netinet/ip_output.c  	   L828 : ip_fragment allocates multiple mbufs to fragment packets - need to track UID mapping here
netinet/ip_output.c  	   L841 : ip_fragment calls m_dup_pkthdr which clones all tags (NB: will need to overwrite), maybe allocating memory for them
netinet/ip_output.c  	   L868 : ip_fragment uses m_copym to (read only (?)) copy packet data into the fragments
netinet/ip_output.c  	   L894 : ip_fragment calls m_adj on the original packet - this will end up freeing most of the mbuf chain
netinet/ip_output.c  	   L697 : ip_output hands mbuf to interface's if_output - packet leaves IP layer
netinet/ip_output.c  	   L700 : ip_output frees rest of mbuf chain if we encounter an error sending
netinet/ip_output.c  	   L724 : ip_output frees mbuf chain if we encountered an error before

-- IP layer calls ip_output of specific interface --


--- Going up network stack ---

-- Interface calls netisr_dispatch --
net/netisr.c			   L1100 : netisr_dispatch_src may give up and free packet if protocol is disabled
net/netisr.c			   L1047 : netisr_queue_src may give up and free packet if protocol is disabled
net/netisr.c			   L801  : netisr_select_cpuid calls next layer up's np_m2cpuid, which may modify the packet (and therefore allocate?) - probably feasible to inspect this function for each layer 3 protocol
net/netisr.c			   L825  : netisr_select_cpuid calls next layer up's np_m2flow, which may modify the packet (and therefore allocate?) - doesn't seem to be used by any compiled-in layer 3 protocols
net/netisr.c			   L995  : netisr_queue_workstream may free packet if no buffer space in the work queue

-- netisr completed -- 
-- IP layer: ip_input --








NB: looks like NETISR_IP and NETISR_IP6 may be used to receive packets


